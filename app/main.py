#!/usr/bin/env python3
"""
Pure Python Debian Package Generator
Creates .deb package with CA cert, server cert, client cert under /opt/config/
"""

import os
import tarfile
import shutil
from app.services.certificate_service import generate_certificates


def create_ar_archive(output_file, files):
    """
    Create a Debian-compatible AR archive using pure Python.
    This implementation follows the GNU ar format with exact byte specifications
    for cross-platform compatibility (Windows, macOS, Linux).
    """
    print(f"Creating AR archive: {output_file}")
    try:
        with open(output_file, 'wb') as ar_file:
            # Write AR magic header
            ar_file.write(b'!<arch>\n')

            for file_path in files:
                stat = os.stat(file_path)
                file_size = stat.st_size
                file_name = os.path.basename(file_path)

                # AR header format is exactly 60 bytes:
                # - file name (16 bytes, padded with spaces)
                # - modification time (12 bytes, padded with spaces)
                # - owner ID (6 bytes, padded with spaces)
                # - group ID (6 bytes, padded with spaces)
                # - file mode (8 bytes, padded with spaces)
                # - file size (10 bytes, padded with spaces)
                # - file magic (2 bytes: backtick + newline)

                # Build header components
                name_field = file_name.ljust(16)[:16]
                time_field = str(int(stat.st_mtime)).ljust(12)[:12]
                uid_field = '0'.ljust(6)
                gid_field = '0'.ljust(6)
                mode_field = '100644'.ljust(8)
                size_field = str(file_size).ljust(10)[:10]
                magic_field = '`\n'

                # Construct the full header (must be exactly 60 bytes)
                header = f"{name_field}{time_field}{uid_field}{gid_field}{mode_field}{size_field}{magic_field}"

                # Ensure header is exactly 60 bytes
                if len(header) != 60:
                    raise ValueError(f"Header length is {len(header)}, expected 60 bytes")

                # Write header as ASCII bytes
                ar_file.write(header.encode('ascii'))

                # Write file content
                with open(file_path, 'rb') as f:
                    content = f.read()
                    ar_file.write(content)

                # AR format requires 2-byte alignment - add newline if file size is odd
                if file_size % 2 != 0:
                    ar_file.write(b'\n')

        print("✓ AR archive created successfully")
        return True
    except Exception as e:
        print(f"Error creating AR archive: {e}")
        import traceback
        traceback.print_exc()
        return False


def set_permissions(file_path, mode):
    """Set file permissions"""
    try:
        os.chmod(file_path, mode)
    except Exception:
        pass


def create_deb_package():
    """
    Create Debian package with certificates and config in /opt/config/
    """

    package_name = "sample-config-pkg"
    version = "1.0.0"
    architecture = "all"
    maintainer = "Admin <admin@example.com>"
    description = "Sample package with certificates and configuration"

    package_dir = f"{package_name}_{version}_{architecture}"
    deb_file = f"{package_dir}.deb"
    build_dir = "build"

    # Clean up
    print("Cleaning up previous builds...")
    for item in [build_dir, deb_file, "debian-binary", "control.tar.gz", "data.tar.gz"]:
        if os.path.exists(item):
            if os.path.isdir(item):
                shutil.rmtree(item)
            else:
                os.remove(item)

    # Create directory structure
    print("Creating package structure...")
    certs_dir = os.path.join(build_dir, "opt", "config", "certs")
    config_dir = os.path.join(build_dir, "opt", "config")
    os.makedirs(certs_dir, exist_ok=True)

    # Generate certificates
    generate_certificates(certs_dir)

    # Set permissions
    for cert_file in ["ca.crt", "server.crt", "client.crt"]:
        set_permissions(os.path.join(certs_dir, cert_file), 0o644)
    for key_file in ["ca.key", "server.key", "client.key"]:
        set_permissions(os.path.join(certs_dir, key_file), 0o600)

    # Create test.conf
    print("Creating test.conf...")
    test_conf_content = """\
# Sample Configuration File
# Generated by sample-config-pkg

[settings]
host=localhost
port=443
ssl_enabled=true

[certificates]
ca_cert=/opt/config/certs/ca.crt
server_cert=/opt/config/certs/server.crt
server_key=/opt/config/certs/server.key
client_cert=/opt/config/certs/client.crt
client_key=/opt/config/certs/client.key

[logging]
log_level=info
log_file=/var/log/sample-app.log
"""

    with open(os.path.join(config_dir, "test.conf"), "w", newline='\n') as f:
        f.write(test_conf_content)

    # Create DEBIAN control directory
    print("Creating control files...")
    control_dir = os.path.join(build_dir, "DEBIAN")
    os.makedirs(control_dir, exist_ok=True)

    # Create control file
    control_content = f"""\
Package: {package_name}
Version: {version}
Architecture: {architecture}
Maintainer: {maintainer}
Description: {description}
"""
    with open(os.path.join(control_dir, "control"), "w", newline='\n') as f:
        f.write(control_content)

    # Create preinst script
    preinst_content = """\
#!/bin/bash
set -e
echo "Running pre-installation script..."
if [ -d "/opt/config" ]; then
    echo "Backing up existing configuration..."
    if [ -d "/opt/config_backup" ]; then
        rm -rf /opt/config_backup
    fi
    mv /opt/config /opt/config_backup
fi
mkdir -p /opt/config/certs
echo "Pre-installation script finished."
exit 0
"""
    preinst_path = os.path.join(control_dir, "preinst")
    with open(preinst_path, "w", newline='\n') as f:
        f.write(preinst_content)
    set_permissions(preinst_path, 0o755)

    # Create postinst script
    postinst_content = """\
#!/bin/bash
set -e
echo "Running post-installation script..."
chmod 644 /opt/config/certs/*.crt
chmod 600 /opt/config/certs/*.key
chmod 644 /opt/config/test.conf
echo "Post-installation script finished."
exit 0
"""
    postinst_path = os.path.join(control_dir, "postinst")
    with open(postinst_path, "w", newline='\n') as f:
        f.write(postinst_content)
    set_permissions(postinst_path, 0o755)

    # Create postrm script
    postrm_content = """\
#!/bin/bash
set -e
echo "Running post-removal script..."
if [ "$1" = "purge" ]; then
    echo "Purging configuration..."
    if [ -d "/opt/config" ]; then
        rm -rf /opt/config
    fi
    if [ -d "/opt/config_backup" ]; then
        rm -rf /opt/config_backup
    fi
fi
echo "Post-removal script finished."
exit 0
"""
    postrm_path = os.path.join(control_dir, "postrm")
    with open(postrm_path, "w", newline='\n') as f:
        f.write(postrm_content)
    set_permissions(postrm_path, 0o755)


    # Create control.tar.gz with explicit binary mode for cross-platform compatibility
    print("Creating control.tar.gz...")
    with tarfile.open("control.tar.gz", "w:gz", format=tarfile.GNU_FORMAT) as tar:
        tar.add(control_dir, arcname=".")

    # Create data.tar.gz with explicit binary mode for cross-platform compatibility
    print("Creating data.tar.gz...")
    with tarfile.open("data.tar.gz", "w:gz", format=tarfile.GNU_FORMAT) as tar:
        for item in os.listdir(build_dir):
            if item != "DEBIAN":
                item_path = os.path.join(build_dir, item)
                tar.add(item_path, arcname=item)

    # Create debian-binary with Unix line ending (LF) - critical for compatibility
    print("Creating debian-binary...")
    with open("debian-binary", "wb") as f:
        # Must use LF (Unix line ending) even on Windows for Debian package compatibility
        f.write(b"2.0\n")

    # Assemble .deb package
    print("Assembling .deb package...")
    if not create_ar_archive(deb_file, ["debian-binary", "control.tar.gz", "data.tar.gz"]):
        print("Failed to create .deb package. Aborting.")
        return

    print(f"\n✓ Package created: {deb_file}")
    print(f"✓ Package size: {os.path.getsize(deb_file)} bytes")

    # Cleanup
    print("\nCleaning up...")
    shutil.rmtree(build_dir)
    os.remove("debian-binary")
    os.remove("control.tar.gz")
    os.remove("data.tar.gz")

    print("\n" + "="*60)
    print("PACKAGE BUILD COMPLETE")
    print("="*60)
    print(f"Package: {deb_file}")
    print("\nVerify (macOS):")
    print(f"  ar -x {deb_file}")
    print("\nInstall (Ubuntu):")
    print(f"  sudo apt install ./{deb_file}")
    print("="*60)


if __name__ == "__main__":
    try:
        print("="*60)
        print("Debian Package Generator")
        print("="*60)
        print()
        create_deb_package()
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
